# Java(JVM) Services

我们一起设计和完善Java（JVM平台语言：Groovy、Scala、Clojure、Kotlin）咨询、培训、教育课程。

### 本课程的初衷和目标

Java(JVM)是最大的开发者语言和应用平台，我们一起交流、学习、掌握Java(JVM)语言和DevOps技能，在技术世界里找到更多机会和自信！

![ilovecoffee](https://wiki.huihoo.com/images/c/c9/I-love-coffee-680x100.jpg)

### 生态系统（ecosystem）
![awesome](https://wiki.huihoo.com/images/1/13/Awesome.png)
* [Awesome Java](https://github.com/akullpp/awesome-java) 和 [Java ecosystem](https://wiki.huihoo.com/wiki/Java_ecosystem)
* [Awesome Scala](https://github.com/lauris/awesome-scala) 和 [Scala ecosystem](https://wiki.huihoo.com/wiki/Scala_ecosystem)
* [Awesome Clojure](https://github.com/razum2um/awesome-clojure) 和 [Clojure ecosystem](https://wiki.huihoo.com/wiki/Clojure_ecosystem)
* [Awesome Kotlin](https://github.com/KotlinBy/awesome-kotlin) 和 [Kotlin ecosystem](https://wiki.huihoo.com/wiki/Kotlin_ecosystem)
* [Awesome Groovy](https://github.com/kdabir/awesome-groovy)

### 深入Java虚拟机（JVM）

深入理解Java虚拟机能帮助我们更好的驾驭Java语言和JVM生态系统，它是资深Java技术专家的必由之路。

我们整理了一些网络上比较系统化的Java文章，主要来自IBM developerWorks，IBM是Java语言最重要的参与者和推动者。文章虽然有点老，但包含的Java基本思想和基础知识依然有用，个人觉得对大家仍很有参考价值。

大家可在这些内容上继续展开和深入。

### Java 理论与实践

* [Java 理论与实践: 应该在下一个企业应用程序中使用 JMS 吗？](https://www.ibm.com/developerworks/cn/java/j-jtp/part1/index.html) 学习消息排队是如何能够改进企业应用程序的灵活性和可伸缩性的
* [Java 理论与实践: 线程池与工作队列](https://www.ibm.com/developerworks/cn/java/j-jtp0730/index.html) 线程池有助于实现最佳资源利用率
* [Java 理论与实践: 嗨，我的线程到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0924/index.html) 了解如何避免服务器应用程序中的线程泄漏
* [Java 理论与实践: 您的小数点到哪里去了？](https://www.ibm.com/developerworks/cn/java/j-jtp0114/index.html) 使用浮点数和小数中的技巧和陷阱
* [Java 理论与实践: 并发在一定程度上使一切变得简单](https://www.ibm.com/developerworks/cn/java/j-jtp1126/index.html) util.concurrent 包简介
* [Java 理论与实践: 变还是不变？](https://www.ibm.com/developerworks/cn/java/j-jtp02183/index.html) 不变对象能极大地简化您的生活
* [Java 理论与实践: 哈希](https://www.ibm.com/developerworks/cn/java/j-jtp05273/index.html) 有效和正确定义hashCode()和equals()
* [Java 理论与实践: 构建一个更好的 HashMap](https://www.ibm.com/developerworks/cn/java/j-jtp08223/index.html) ConcurrentHashMap 如何在不损失线程安全的同时提供更高的并发性
* [Java 理论与实践: 并发集合类](https://www.ibm.com/developerworks/cn/java/j-jtp07233/index.html) ConcurrentHashMap 和 CopyOnWriteArrayList 提供线程安全性和已改进的可伸缩性
* [Java 理论与实践: 描绘线程安全性](https://www.ibm.com/developerworks/cn/java/j-jtp09263/index.html) 线程安全不是一个非真即假的命题
* [Java 理论与实践: JVM 1.4.1 中的垃圾收集](https://www.ibm.com/developerworks/cn/java/j-jtp11253/index.html) 分代垃圾收集和并发垃圾收集
* [Java 理论与实践: 垃圾收集简史](https://www.ibm.com/developerworks/cn/java/j-jtp10283/index.html) 垃圾收集是如何工作的？
* [Java 理论与实践: 修复 Java 内存模型，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-jtp03304/index.html) 在 JSR 133 中 JMM 会有什么改变？
* [Java 理论与实践: 关于异常的争论](https://www.ibm.com/developerworks/cn/java/j-jtp05254/index.html) 要检查，还是不要检查？
* [Java 理论与实践: 消除 bug](https://www.ibm.com/developerworks/cn/java/j-jtp06294/index.html) FindBugs 之类的检测工具提供了防止常见编码错误的另一层防护
* [Java 理论与实践: Web 层的状态复制](https://www.ibm.com/developerworks/cn/java/j-jtp07294/index.html) 有多种用于群集 Web 应用程序的方法
* [Java 理论与实践: JDK 5.0 中更灵活、更具可伸缩性的锁定机制](https://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html) 新的锁定类提高了同步性 —— 但还不能现在就抛弃 synchronized
* [Java 理论与实践: 流行的原子](https://www.ibm.com/developerworks/cn/java/j-jtp11234/index.html) 新原子类是 java.util.concurrent 的隐藏精华
* [Java 理论与实践: 动态编译与性能测量](https://www.ibm.com/developerworks/cn/java/j-jtp12214/index.html) 动态编译情况下指标评测的风险
* [Java 理论与实践: 做个好的（事件）侦听器](https://www.ibm.com/developerworks/cn/java/j-jtp07265/index.html) 事件侦听器编写和支持指南
* [Java 理论与实践: 再谈 Urban 性能传言](https://www.ibm.com/developerworks/cn/java/j-jtp09275.html) 分配比想像的要快，而且会变得更快
* [Java 理论与实践: 用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/index.html) 弱引用使得表达对象生命周期关系变得容易了
* [Java 理论与实践: 伪 typedef 反模式](https://www.ibm.com/developerworks/cn/java/j-jtp02216.html) 扩展不是类型定义
* [Java 理论与实践: 良好的内务处理实践](https://www.ibm.com/developerworks/cn/java/j-jtp03216.html) 您的资源是否没有及时释放？
* [Java 理论与实践: 非阻塞算法简介](https://www.ibm.com/developerworks/cn/java/j-jtp04186/index.html) 看吧，没有锁定！
* [Java 理论与实践: 处理 InterruptedException](https://www.ibm.com/developerworks/cn/java/j-jtp05236.html) 捕捉到它，然后怎么处理它？
* [Java 理论与实践: 平衡测试，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-jtp06206.html) 不要仅编写测试，还要编写 bug 检测器
* [Java 理论与实践: 用 JMX 检测应用程序](https://www.ibm.com/developerworks/cn/java/j-jtp09196/index.html) 只需添加 bean 就可实现立即可视
* [Java 理论与实践: 理解 JTS —— 事务简介](https://www.ibm.com/developerworks/cn/java/j-jtp0305.html) 事务是可靠应用程序的构建块
* [Java 理论与实践: 在 JDK 早期版本中使用 Java 5 的语言特性](https://www.ibm.com/developerworks/cn/java/j-jtp02277.html) 即使只能用 JDK 1.4，也可以使用泛型
* [Java 理论与实践: 闭包之争](https://www.ibm.com/developerworks/cn/java/j-jtp04247.html) Java 语言是否应增加闭包以及如何添加？
* [Java 理论与实践: 正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html) volatile 变量使用指南
* [Java 理论与实践: 应用 fork-join 框架](https://www.ibm.com/developerworks/cn/java/j-jtp11137.html) 学习如何使用 Java 7 中的 fork-join 框架实现细粒度并行性
* [Java 理论与实践: 使用通配符简化泛型使用](https://www.ibm.com/developerworks/cn/java/j-jtp04298.html) 理解通配符捕获
* [Java 理论与实践: 用动态代理进行修饰](https://www.ibm.com/developerworks/cn/java/j-jtp08305.html) 动态代理是构建 Decorator 和 Adapter 的方便工具

### Java 开发 2.0

* [Java 开发 2.0: 使用 Google App Engine](https://www.ibm.com/developerworks/cn/java/j-javadev2-1/index.html) 利用 Groovy、Eclipse 和 JDO 进行快速 Web 应用程序开发
* [Java 开发 2.0: 您也可以租用 EC2](https://www.ibm.com/developerworks/cn/java/j-javadev2-2/index.html) 以灵活且低成本的方式创建高效、可伸缩的租借的基础设施
* [Java 开发 2.0: 使用方便的 EC2](https://www.ibm.com/developerworks/cn/java/j-javadev2-4/index.html) 快速创建 CRUD Web 应用程序并在 Amazon Elastic Compute Cloud 上运行它
* [Java 开发 2.0: 通过 CouchDB 和 Groovy 的 RESTClient 实现 REST](https://www.ibm.com/developerworks/cn/java/j-javadev2-5/index.html) REST 式概念和面向文档的数据库实战
* [Java 开发 2.0: 针对 Google App Engine 的 Gaelyk](https://www.ibm.com/developerworks/cn/java/j-javadev2-6/index.html) 基于 Groovy 的框架加速 Google App Engine 上的开发工作
* [Java 开发 2.0: Kilim 简介](https://www.ibm.com/developerworks/cn/java/j-javadev2-7.html) 一种用于实现 Java 并发性的角色框架
* [Java 开发 2.0: NoSQL](https://www.ibm.com/developerworks/cn/java/j-javadev2-8/index.html) 使用 Bigtable 和 Groovy 的 Gaelyk 进行无模式数据建模
* [Java 开发 2.0: 使用 Amazon SimpleDB 进行云存储，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-javadev2-9/index.html) 开始使用 SimpleDB 和 Amazon SDK
* [Java 开发 2.0: 使用 Amazon SimpleDB 实现云存储，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-javadev2-10.html) 使用 SimpleJPA 实现简单对象持久化
* [Java 开发 2.0: 使用 Hibernate Shards 进行切分](https://www.ibm.com/developerworks/cn/java/j-javadev2-11/index.html) 关系数据库的水平伸缩
* [Java 开发 2.0: MongoDB：拥有 RDBMS 特性的 NoSQL 数据存储](https://www.ibm.com/developerworks/cn/java/j-javadev2-12/index.html) 使用 Java 代码和 Groovy 创建和查询文档
* [Java 开发 2.0: 使用 Objectify-Appengine 进行 Twitter 挖掘，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-javadev2-13/index.html) 对象域建模和非关系型数据存储的持久性
* [Java 开发 2.0: 使用 Objectify-Appengine 进行 Twitter 挖掘，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-javadev2-14/index.html) 通过 Gaelyk、JSON 和 Ajax 快速创建 GAE Web 应用程序
* [Java 开发 2.0: 用 Hadoop MapReduce 进行大数据分析](https://www.ibm.com/developerworks/cn/java/j-javadev2-15/index.html) 成堆的数据如何变成信息金矿
* [Java 开发 2.0: 攀登 Elastic Beanstalk](https://www.ibm.com/developerworks/cn/java/j-javadev2-16/index.html) 使用 Amazon 无限灵活的 PaaS 扩展云
* [Java 开发 2.0: 使用 Amazon SQS 进行基于云计算的消息传送](https://www.ibm.com/developerworks/cn/java/j-javadev2-17/index.html) 使用 Amazon 的消息队列系统
* [Java 开发 2.0: 面向 Java 开发人员的 JavaScript](https://www.ibm.com/developerworks/cn/java/j-javadev2-18/index.html) Java 开发人员关于 JavaScript 变量、类型、函数等的初级读本
* [Java 开发 2.0: Play 框架在 Amazon RDS 中的应用](https://www.ibm.com/developerworks/cn/java/j-javadev2-19/index.html) 关系数据管理即服务？为什么不是？
* [Java 开发 2.0: 使用 Gretty 的超轻量级 Java Web 服务](https://www.ibm.com/developerworks/cn/java/j-javadev2-20/index.html) Gretty 丢弃 Web 堆栈来实现真正的快速应用程序开发
* [Java 开发 2.0: 通过 Heroku 的 PaaS 用 Git 提交 Java 应用程序](https://www.ibm.com/developerworks/cn/java/j-javadev2-21/index.html) Heroku 扩展其 Ruby 功能以实现 Java 应用程序可扩展性
* [Java 开发 2.0: 现实世界中的 Redis](https://www.ibm.com/developerworks/cn/java/j-javadev2-22/index.html) Redis 如何在包含大量读取操作的应用程序中战胜 memcached
* [Java 开发 2.0: 保护用于云计算的 Java 应用程序数据](https://www.ibm.com/developerworks/cn/java/j-javadev2-23/index.html) 使用私钥加密来保护云数据
* [Java 开发 2.0: 通过 ElasticSearch 进行可伸缩搜索](https://www.ibm.com/developerworks/cn/java/j-javadev2-24/index.html) Java 企业应用程序的分布式搜索

### Java 下一代

* [Java 下一代: Groovy、Scala 和 Clojure](https://www.ibm.com/developerworks/cn/java/j-jn1/index.html) 在日益壮大的多语言世界中使用 Groovy、Scala 和 Clojure
* [Java 下一代: Groovy、Scala 和 Clojure 中的共同点，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-jn2/index.html) 探究这些下一代 JVM 语言如何处理操作符重载
* [Java 下一代: Groovy、Scala 和 Clojure 中的共同点，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-jn3/index.html) 了解Java 下一代语言如何减少样板代码和降低复杂性
* [Java 下一代: Groovy、Scala 和 Clojure 中的共同点，第 3 部分](https://www.ibm.com/developerworks/cn/java/j-jn4/index.html) 反思异常、表达式和空
* [Java 下一代: 没有继承性的扩展，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-jn5/index.html) 了解 Groovy、Scala 和 Clojure 如何将行为融入到类中
* [Java 下一代: 没有继承性的扩展，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-jn6/index.html) 探索 Clojure 协议
* [Java 下一代: 没有继承性的扩展，第 3 部分](https://www.ibm.com/developerworks/cn/java/j-jn7/index.html) Groovy 元编程为您提供常见问题的简单解决方案
* [Java 下一代: 混入和特征](https://www.ibm.com/developerworks/cn/java/j-jn8/index.html) 将新行为混合到 Groovy 和 Scala 类中
* [Java 下一代: 局部套用和部分应用](https://www.ibm.com/developerworks/cn/java/j-jn9/index.html) 为函数调度添加功能和间接引用
* [Java 下一代: 函数式编码风格](https://www.ibm.com/developerworks/cn/java/j-jn10/index.html) Groovy、Scala 和 Clojure 共享的函数结构及其优势
* [Java 下一代: 克服同义词干扰](https://www.ibm.com/developerworks/cn/java/j-jn11/index.html) 认识不同 Java.net 语言中类似的函数结构
* [Java 下一代: 内存化和函数式协同](https://www.ibm.com/developerworks/cn/java/j-jn12/index.html) 核心函数特性及 Java 下一代语言如何实现和组合它们
* [Java 下一代: 对比并发性](https://www.ibm.com/developerworks/cn/java/j-jn13/index.html) 了解 Java 下一代语言中的并发性选项有何不同
* [Java 下一代: Clojure 中的并发性](https://www.ibm.com/developerworks/cn/java/j-jn14/index.html) Clojure 如何抽象并发性和共享状态
* [Java 下一代: 使用 Java 8 作为 Java 下一代语言](https://www.ibm.com/developerworks/cn/java/j-jn15/index.html) 评估 Java 8 是否适合代替 Java
* [Java 下一代: 选择您的下一个 JVM 语言](https://www.ibm.com/developerworks/cn/java/j-jn16/index.html)

### 函数式思维

* [函数式思维: 以函数式的方式思考，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-ft1/index.html) 学习如何像函数式程序员一样思考
* [函数式思维: 运用函数式思维，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-ft2/index.html) 探索函数编程和控制
* [函数式思维: 运用函数式思维，第 3 部分](https://www.ibm.com/developerworks/cn/java/j-ft3/index.html) 过滤、单元测试和代码重用的技巧
* [函数式思维: 不变性](https://www.ibm.com/developerworks/cn/java/j-ft4/index.html) 通过较少的改动来提供功能更强大的 Java 代码
* [函数式思维: 耦合和组合，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-ft5/index.html) 探讨原生耦合抽象的含义
* [函数式思维: 耦合和组合，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-ft6/index.html) 面向对象构建块 VS 函数式构建块
* [函数式思维: Groovy 中的函数式特性，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-ft7/index.html) 隐藏在 Groovy 中的宝藏
* [函数式思维: Groovy 中的函数式特性，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-ft8/index.html) 元编程 + Functional Java
* [函数式思维: Groovy 中的函数式特性，第 3 部分](https://www.ibm.com/developerworks/cn/java/j-ft9/index.html) 内存化和缓存
* [函数式思维: 函数设计模式，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-ft10/index.html) 模式在函数世界中的表现方式
* [函数式思维: 函数设计模式，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-ft11/index.html) 相同的问题，不同的范式
* [函数式思维: 函数设计模式，第 3 部分](https://www.ibm.com/developerworks/cn/java/j-ft12/index.html) 解释器模式和扩展语言
* [函数式思维: 利用 Either 和 Option 进行函数式错误处理](https://www.ibm.com/developerworks/cn/java/j-ft13/index.html) 类型安全的函数式异常
* [函数式思维: Either 树和模式匹配](https://www.ibm.com/developerworks/cn/java/j-ft14/index.html) 使用 Either 和泛型在 Java 中创建 Scala 风格的模式匹配
* [函数式思维: 对调度（dispatch）的反思](https://www.ibm.com/developerworks/cn/java/j-ft15/index.html) 下一代 JVM 语言如何为方法调度添加一些玄妙之处
* [函数式思维: 大量转换](https://www.ibm.com/developerworks/cn/java/j-ft16/index.html) 同义词掩盖了相似性
* [函数式思维: 转换和优化](https://www.ibm.com/developerworks/cn/java/j-ft17/index.html) 各种语言的更多功能比较
* [函数式思维: 惰性计算，第 1 部分](https://www.ibm.com/developerworks/cn/java/j-ft18/index.html) 探索 Java 中的惰性计算
* [函数式思维: 惰性计算，第 2 部分](https://www.ibm.com/developerworks/cn/java/j-ft19/index.html) 深入探讨惰性评估
* [函数式思维: 为什么函数式编程越来越受关注](https://www.ibm.com/developerworks/cn/java/j-ft20/index.html) 为什么即使短期内不打算改变语言也应该关心函数式编程

## Groovy程序设计与实践

我们会从语法、语义、操作符、程序结构、面向对象、特征、闭包、元对象编程、DSL、测试、设计模式和应用等方面对Groovy编程语言进行深入学习。

我们会在Gradle、Jenkins流水线、测试和电商新零售等行业应用对Groovy做深度展开。

[Groovy程序设计与实践](groovy-training/README.md)

## 2004年灰狐Java培训教程

看看那时Java培训都关注些什么？

那时的Web框架主要是Struts，而现在基本都是Spring的天下。

2004年那个时期的行业形态：

Gartner Group : 70% of Java projects fail due to lack of skills 

There are 2.5 Million Java developers in the world. Only 800,000 of them have genuine knowledge. 70 percent of these developers agree that the lack of advanced Java skills makes adoption of EJB/J2EE risky. ... 

[灰狐2004 Java 培训课程](java-training-2004/README.md)

## 关联外部项目
* git submodule add https://github.com/aalansehaiyang/java8-tutorial java8-tutorial

## 许可方式 License

课程和课件采用CC

[![CC](http://wiki.huihoo.com/images/4/4e/CC-BY-SA_3.0-88x31.png)](http://wiki.huihoo.com/wiki/CC-BY-SA_3.0)

代码采用Apache v2

## 赞助与支持
本服务教程为免费教程，若需要得到更多技术支持，可通过赞助我们的方式获得。

![灰狐会员](http://wiki.huihoo.com/images/2/25/Zsxq.jpg)

[灰狐会员](https://wiki.huihoo.com/wiki/%E7%81%B0%E7%8B%90%E4%BC%9A%E5%91%98)
